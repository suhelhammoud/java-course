---
theme:
  override:
    code:
        alignment: left
        margin:
            percent: 5
    #   padding:
        # horizontal: 4
---

Records in Java
===

# Using Record to Model Immutable Data

The Java language gives you several ways to create an immutable class. Probably the most straightforward way is to create a final class with final fields and a constructor to initialize these fields. Here is an example of such a class.

```java
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Now that you have written these elements, you need to add the accessors for your fields. You will also add a `toString()` method and probably an `equals()` along with an `hashCode()` method.

<!-- end_slide -->

# The Problem with Traditional Approach

Writing all this by hand is quite tedious and error-prone, fortunately, your IDE is there to generate these methods for you.

If you need to carry the instances of this class from one application to another, either by sending them over a network or through a file system, you may also consider making this class serializable.

In the end, your `Point` class may be a hundred lines long, mostly populated with code generated by your IDE.

<!-- end_slide -->

# Calling Records to the Rescue

Records have been added to the JDK to change this. Starting with Java SE 14, you can write:

```java
public record Point(int x, int y) {}
```

This single line of code creates:
- An immutable class with two fields: x and y
- A canonical constructor
- `toString()`, `equals()` and `hashCode()` methods
- Can implement `Serializable`

<!-- end_slide -->

# The Class of a Record

A record is class declared with the `record` keyword instead of `class`.

```java
public record Point(int x, int y) {}
```

Key characteristics:
- The class is final
- Extends `java.lang.Record`
- Cannot extend any other class
- Can implement any number of interfaces

<!-- end_slide -->

# Declaring Record Components

The block that immediately follows the name of the record declares its components.

```java
public record Point(int x, int y) {}
```

For each component:
- Private final field is created
- Accessor method is generated (e.g., `x()`)
- Default `toString()`, `equals()` and `hashCode()` are created

<!-- end_slide -->

# Restrictions on Records

Things you cannot add to a record:
1. Cannot declare any instance field not corresponding to a component
2. Cannot define any field initializer
3. Cannot add any instance initializer

You can:
- Create static fields with initializers
- Add static initializers

<!-- end_slide -->

# Constructing a Record

The compiler creates a canonical constructor that takes the components as arguments.

Two ways to customize it:
1. Compact constructor (doesn't declare parameters)
2. Regular canonical constructor

Example of compact constructor:
```java
public record Range(int start, int end) {
    public Range {
        if (end <= start) throw new IllegalArgumentException(...);
    }
}
```

<!-- end_slide -->

# Defining Additional Constructors

You can add any constructor as long as it calls the canonical constructor.

Example:
```java
public record State(String name, String capitalCity, List<String> cities) {
    public State(String name, String capitalCity) {
        this(name, capitalCity, List.of());
    }
    
    public State(String name, String capitalCity, String... cities) {
        this(name, capitalCity, List.of(cities));
    }
}
```

<!-- end_slide -->

# Accessor Methods

Records automatically generate accessor methods named after components.

Example for `Point`:
```java
public int x() { return this.x; }
public int y() { return this.y; }
```

You can override them if needed, for example to return defensive copies.

<!-- end_slide -->

# Serializing Records

Records can be serialized if they implement `Serializable`:
- Cannot customize serialization process (no `writeObject/readObject`)
- Deserialization always calls the canonical constructor
- Can use `readResolve()` and `writeReplace()`

This makes records excellent for data transport objects.

<!-- end_slide -->

# Practical Use Case: Local Records

Records can be used locally to improve code readability.

Example: Finding the state with most cities
```java
record NumberOfCitiesPerState(State state, long numberOfCities) {
    public NumberOfCitiesPerState(Map.Entry<State, Long> entry) {
        this(entry.getKey(), entry.getValue());
    }
    
    public static Comparator<NumberOfCitiesPerState> comparingByNumberOfCities() {
        return Comparator.comparing(NumberOfCitiesPerState::numberOfCities);
    }
}
```

